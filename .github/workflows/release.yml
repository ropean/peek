name: Build and Release

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag version (e.g., v1.0.0)"
        required: true
        type: string

permissions:
  contents: write
  actions: read

env:
  CARGO_TERM_COLOR: always
  RELEASE_TAG: ${{ github.event.inputs.tag || github.ref_name }}

jobs:
  build:
    name: Build ${{ matrix.platform.target }}
    runs-on: ${{ matrix.platform.os }}

    strategy:
      fail-fast: false
      matrix:
        platform:
          # Windows
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: peek-windows-x64.exe
            upx: true
            strip: false
          - os: windows-latest
            target: i686-pc-windows-msvc
            name: peek-windows-x86.exe
            upx: true
            strip: false

          # macOS - Build binaries only
          - os: macos-latest
            target: x86_64-apple-darwin
            name: peek-macos-x64
            upx: false
            strip: true
            build_app: false
          - os: macos-latest
            target: aarch64-apple-darwin
            name: peek-macos-arm64
            upx: false
            strip: true
            build_app: false
          # macOS - Build .app bundles
          - os: macos-latest
            target: x86_64-apple-darwin
            name: Peek-x64.app
            upx: false
            strip: true
            build_app: true
            arch: x86_64
          - os: macos-latest
            target: aarch64-apple-darwin
            name: Peek-arm64.app
            upx: false
            strip: true
            build_app: true
            arch: arm64

          # Linux
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: peek-linux-x64
            upx: true
            strip: false
          - os: ubuntu-latest
            target: i686-unknown-linux-gnu
            name: peek-linux-x86
            upx: true
            strip: false
          # ARM platforms require more complex cross-compilation setup
          # - os: ubuntu-latest
          #   target: aarch64-unknown-linux-gnu
          #   name: peek-linux-arm64
          #   upx: true
          #   strip: false
          # - os: ubuntu-latest
          #   target: armv7-unknown-linux-gnueabihf
          #   name: peek-linux-armv7
          #   upx: true
          #   strip: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform.target }}

      - name: Install Linux dependencies (x86)
        if: matrix.platform.target == 'i686-unknown-linux-gnu'
        run: |
          sudo dpkg --add-architecture i386
          sudo apt-get update
          sudo apt-get install -y gcc-multilib g++-multilib libssl-dev:i386

      - name: Install Linux dependencies (ARM64)
        if: matrix.platform.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

      - name: Install Linux dependencies (ARMv7)
        if: matrix.platform.target == 'armv7-unknown-linux-gnueabihf'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ matrix.platform.target }}-${{ hashFiles('**/Cargo.lock') }}

      - name: Install UPX (Windows)
        if: runner.os == 'Windows' && matrix.platform.upx
        run: choco install upx -y

      - name: Install UPX (macOS)
        if: runner.os == 'macOS' && matrix.platform.upx
        run: brew install upx

      - name: Install UPX (Linux)
        if: runner.os == 'Linux' && matrix.platform.upx
        run: |
          sudo apt-get update
          sudo apt-get install -y upx

      - name: Build application
        shell: bash
        run: |
          # Check if this is native build (host matches target)
          HOST_TARGET=$(rustc -vV | sed -n 's|host: ||p')
          BUILD_TARGET="${{ matrix.platform.target }}"
          IS_APP_BUILD="${{ matrix.platform.build_app || 'false' }}"

          if [ "$IS_APP_BUILD" = "true" ]; then
            echo "Building .app bundle for $BUILD_TARGET"
            
            # Build the release binary
            cargo build --release --target $BUILD_TARGET
            
            # Create .app bundle
            echo "Creating .app bundle..."
            
            # Define app bundle structure
            APP_NAME="Peek-${{ matrix.platform.arch }}.app"
            APP_DIR="$APP_NAME"
            CONTENTS_DIR="${APP_DIR}/Contents"
            MACOS_DIR="${CONTENTS_DIR}/MacOS"
            RESOURCES_DIR="${CONTENTS_DIR}/Resources"
            
            # Create directory structure
            mkdir -p "${MACOS_DIR}"
            mkdir -p "${RESOURCES_DIR}"
            
            # Copy binary
            cp "target/$BUILD_TARGET/release/peek" "${MACOS_DIR}/peek"
            chmod +x "${MACOS_DIR}/peek"
            
            # Create minimal Info.plist
            cat > "${CONTENTS_DIR}/Info.plist" <<EOL
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleExecutable</key>
              <string>peek</string>
              <key>CFBundleIdentifier</key>
              <string>com.peek-rs.peek</string>
              <key>CFBundleName</key>
              <string>Peek</string>
              <key>CFBundleDisplayName</key>
              <string>Peek</string>
              <key>CFBundleVersion</key>
              <string>${{ env.RELEASE_TAG }}</string>
              <key>CFBundleShortVersionString</key>
              <string>${RELEASE_TAG#v}</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>LSMinimumSystemVersion</key>
              <string>10.15</string>
              <key>LSArchitecturePriority</key>
              <array>
                  <string>${{ matrix.platform.arch }}</string>
              </array>
          </dict>
          </plist>
          EOL

            # Copy icon if available
            if [ -f "assets/peek.icns" ]; then
              cp "assets/peek.icns" "${RESOURCES_DIR}/peek.icns"
              # Update Info.plist to include icon
              plutil -insert CFBundleIconFile -string "peek.icns" "${CONTENTS_DIR}/Info.plist"
            fi
            
            # Create a zip of the app bundle
            zip -r "${APP_NAME}.zip" "$APP_NAME"
            
          else
            # Standard binary build
            if [ "$BUILD_TARGET" = "$HOST_TARGET" ]; then
              # Native build: use build.sh for consistency
              echo "Native build detected, using build.sh"
              chmod +x scripts/build.sh
              ./scripts/build.sh
              
              # Move binary to target-specific directory for consistent path handling
              mkdir -p "target/$BUILD_TARGET/release"
              if [ "${{ runner.os }}" = "Windows" ]; then
                cp target/release/peek.exe "target/$BUILD_TARGET/release/peek.exe"
              else
                cp target/release/peek "target/$BUILD_TARGET/release/peek"
              fi
            else
              # Cross-compilation: build directly with cargo
              echo "Cross-compilation build: $HOST_TARGET -> $BUILD_TARGET"
              cargo build --release --target $BUILD_TARGET
              
              # Determine executable path
              if [ "${{ runner.os }}" = "Windows" ]; then
                EXEC_PATH="target/$BUILD_TARGET/release/peek.exe"
              else
                EXEC_PATH="target/$BUILD_TARGET/release/peek"
              fi
              
              # Apply UPX compression if enabled
              if [ "${{ matrix.platform.upx }}" = "true" ] && command -v upx &>/dev/null; then
                echo "Compressing with UPX..."
                upx --best --lzma "$EXEC_PATH" || echo "UPX compression failed, continuing..."
              fi
              
              # Apply strip if enabled
              if [ "${{ matrix.platform.strip }}" = "true" ]; then
                echo "Original size:"
                ls -lh "$EXEC_PATH"
                strip "$EXEC_PATH"
                echo "After stripping:"
                ls -lh "$EXEC_PATH"
              fi
            fi

            # Show final binary info
            if [ "${{ runner.os }}" = "Windows" ]; then
              ls -lh "target/$BUILD_TARGET/release/peek.exe"
            else
              ls -lh "target/$BUILD_TARGET/release/peek"
            fi
          fi

      - name: Prepare artifact (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          if [ "${{ matrix.platform.build_app }}" = "true" ]; then
            # For app bundles, we already have the zip file
            echo "App bundle already prepared"
          else
            cp target/${{ matrix.platform.target }}/release/peek.exe "${{ matrix.platform.name }}"
          fi

      - name: Prepare artifact (Unix)
        if: runner.os != 'Windows'
        run: |
          if [ "${{ matrix.platform.build_app }}" = "true" ]; then
            # For app bundles, we already have the zip file
            echo "App bundle already prepared"
          else
            cp target/${{ matrix.platform.target }}/release/peek "${{ matrix.platform.name }}"
            chmod +x "${{ matrix.platform.name }}"
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform.name }}
          path: |
            ${{ matrix.platform.name }}
            ${{ matrix.platform.name }}.zip
          retention-days: 7

  # Create release with changelog
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract changelog for current version
        id: changelog
        run: |
          VERSION="${{ env.RELEASE_TAG }}"
          VERSION_NUM="${VERSION#v}"

          # Extract the changelog section for this version
          if grep -q "\[${VERSION_NUM}\]" CHANGELOG.md; then
            # Extract content between this version and the next version header
            CHANGELOG=$(sed -n "/## \[${VERSION_NUM}\]/,/## \[/p" CHANGELOG.md | sed '$d' | tail -n +2)
          else
            # Fallback: generate from git commits since last tag
            LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              CHANGELOG="## What's Changed"$'\n\n'
              git log ${LAST_TAG}..HEAD --pretty=format:"- %s" --reverse >> temp_changelog.txt
              CHANGELOG="${CHANGELOG}$(cat temp_changelog.txt)"
            else
              CHANGELOG="Initial release"
            fi
          fi

          # Save to file for the release
          echo "$CHANGELOG" > release_notes.md
          echo "Changelog extracted successfully"
          cat release_notes.md

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          mkdir -p release-files
          find artifacts -type f \( -name "peek-*" -o -name "Peek-*.zip" \) -exec cp {} release-files/ \;
          ls -lh release-files/

      - name: Create or update release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: Release ${{ env.RELEASE_TAG }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          files: release-files/*
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Create a summary of all builds
  summary:
    name: Build Summary
    needs: [build, release]
    runs-on: ubuntu-latest
    if: always()
    outputs:
      release_tag: ${{ steps.set-tag.outputs.tag }}

    steps:
      - name: Set release tag output
        id: set-tag
        run: echo "tag=${{ env.RELEASE_TAG }}" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display summary
        run: |
          echo "## ðŸŽ‰ Release ${{ env.RELEASE_TAG }} Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Built Platforms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Size |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|------|" >> $GITHUB_STEP_SUMMARY

          for dir in artifacts/*/; do
            if [ -d "$dir" ]; then
              for file in "$dir"*; do
                if [[ -f "$file" && ! "$file" == *.txt ]]; then
                  filename=$(basename "$file")
                  size=$(ls -lh "$file" | awk '{print $5}')
                  echo "| $filename | $size |" >> $GITHUB_STEP_SUMMARY
                fi
              done
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Links" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [View Release](https://github.com/${{ github.repository }}/releases/tag/${{ env.RELEASE_TAG }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Download Assets](https://github.com/${{ github.repository }}/releases/download/${{ env.RELEASE_TAG }}/)" >> $GITHUB_STEP_SUMMARY
